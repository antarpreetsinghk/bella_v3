name: Deploy to AWS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: ca-central-1
  ECR_REPOSITORY: bella-voice-app

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: test_bella
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: 3.11

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-asyncio pytest-cov pytest-timeout

    - name: Run database migrations
      env:
        DATABASE_URL: postgresql+asyncpg://test_user:test_password@localhost:5432/test_bella
      run: |
        alembic upgrade head

    - name: Run tests
      timeout-minutes: 10
      env:
        APP_ENV: testing
        DATABASE_URL: postgresql+asyncpg://test_user:test_password@localhost:5432/test_bella
        OPENAI_API_KEY: test_key
        BELLA_API_KEY: test_api_key
        TWILIO_AUTH_TOKEN: test_token
        TWILIO_ACCOUNT_SID: test_sid
        TWILIO_PHONE_NUMBER: +15551234567
      run: |
        # Run essential tests only in CI for faster deployment, excluding production tests that require deployed Lambda
        pytest tests/ -m "essential" --ignore=tests/production/ --tb=short --quiet --disable-warnings -x --timeout=300

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

  deploy-lambda:
    if: github.ref == 'refs/heads/main' && (needs.test.result == 'success' || contains(github.event.head_commit.message, '[skip-tests]'))
    needs: test
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: 3.11

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Create deployment package
      run: |
        # Clean and create deployment directory
        rm -rf deployment
        mkdir deployment

        # Install minimal Lambda dependencies
        pip install -r requirements-lambda-minimal.txt -t deployment/

        # Copy application code
        cp -r app deployment/
        cp -r alembic deployment/
        cp alembic.ini deployment/

        # Copy the production Lambda handler
        cp lambda_handler.py deployment/

        # Create fallback handler for compatibility
        cat > deployment/handler.py << 'EOF'
        # Fallback handler - main handler is in lambda_handler.py
        from lambda_handler import lambda_handler as handler
        EOF

        # Optimize package size - remove unnecessary files
        cd deployment
        find . -type f -name "*.pyc" -delete
        find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
        find . -type d -name "*.dist-info" -exec rm -rf {} + 2>/dev/null || true
        find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
        find . -type f -name "*.md" -delete 2>/dev/null || true
        find . -type f -name "*.txt" -not -name "alembic.ini" -delete 2>/dev/null || true

        # Create optimized deployment zip
        zip -r ../deployment.zip . -x "*.pyc" "*__pycache__*" "*.git*" "*test*" "*/tests/*"
        cd ..

        # Check package size (70MB = 73,400,320 bytes limit)
        PACKAGE_SIZE=$(stat -f%z deployment.zip 2>/dev/null || stat -c%s deployment.zip)
        LIMIT=70000000
        echo "Package size: ${PACKAGE_SIZE} bytes (limit: ${LIMIT} bytes)"
        if [ $PACKAGE_SIZE -gt $LIMIT ]; then
          echo "‚ùå Package too large: ${PACKAGE_SIZE} bytes > ${LIMIT} bytes"
          exit 1
        else
          echo "‚úÖ Package size OK: ${PACKAGE_SIZE} bytes"
        fi

    - name: Deploy to Lambda
      run: |
        # Check if function exists
        if aws lambda get-function --function-name bella-voice-app 2>/dev/null; then
          echo "Updating existing Lambda function..."
          aws lambda update-function-code \
            --function-name bella-voice-app \
            --zip-file fileb://deployment.zip

          # Update environment variables with advanced call flow support
          aws lambda update-function-configuration \
            --function-name bella-voice-app \
            --environment Variables="{
              APP_ENV=production,
              DATABASE_URL=${{ secrets.DATABASE_URL }},
              REDIS_URL=${{ secrets.REDIS_URL }},
              OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }},
              OPENAI_MODEL=gpt-4o-mini,
              BELLA_API_KEY=${{ secrets.BELLA_API_KEY }},
              TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }},
              TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }},
              TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }},
              GOOGLE_CALENDAR_ENABLED=true,
              GOOGLE_CALENDAR_ID=${{ secrets.GOOGLE_CALENDAR_ID }},
              GOOGLE_SERVICE_ACCOUNT_JSON=${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }},
              BUSINESS_EMAIL=${{ secrets.BUSINESS_EMAIL }}
            }"
        else
          echo "Creating new Lambda function..."
          aws lambda create-function \
            --function-name bella-voice-app \
            --runtime python3.11 \
            --role ${{ secrets.LAMBDA_EXECUTION_ROLE_ARN }} \
            --handler lambda_handler.lambda_handler \
            --zip-file fileb://deployment.zip \
            --timeout 30 \
            --memory-size 512 \
            --environment Variables="{
              APP_ENV=production,
              DATABASE_URL=${{ secrets.DATABASE_URL }},
              REDIS_URL=${{ secrets.REDIS_URL }},
              OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }},
              OPENAI_MODEL=gpt-4o-mini,
              BELLA_API_KEY=${{ secrets.BELLA_API_KEY }},
              TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }},
              TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }},
              TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }},
              GOOGLE_CALENDAR_ENABLED=true,
              GOOGLE_CALENDAR_ID=${{ secrets.GOOGLE_CALENDAR_ID }},
              GOOGLE_SERVICE_ACCOUNT_JSON=${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }},
              BUSINESS_EMAIL=${{ secrets.BUSINESS_EMAIL }}
            }"

          # Create function URL if it doesn't exist
          aws lambda create-function-url-config \
            --function-name bella-voice-app \
            --auth-type NONE \
            --cors '{
              "AllowCredentials": false,
              "AllowHeaders": ["*"],
              "AllowMethods": ["*"],
              "AllowOrigins": ["*"],
              "ExposeHeaders": ["*"],
              "MaxAge": 86400
            }'
        fi

        # Wait for function to be updated
        aws lambda wait function-updated --function-name bella-voice-app

        # Get function URL
        FUNCTION_URL=$(aws lambda get-function-url-config --function-name bella-voice-app --query 'FunctionUrl' --output text)
        echo "Lambda Function URL: $FUNCTION_URL"

    - name: Run database migrations on production
      run: |
        # Create a temporary script to run migrations
        cat > run_migrations.py << 'EOF'
        import subprocess
        import sys
        import os

        # Set the DATABASE_URL from environment
        os.environ['DATABASE_URL'] = '${{ secrets.DATABASE_URL }}'

        try:
            result = subprocess.run(['alembic', 'upgrade', 'head'],
                                  capture_output=True, text=True, check=True)
            print("Migration successful:")
            print(result.stdout)
        except subprocess.CalledProcessError as e:
            print("Migration failed:")
            print(e.stderr)
            sys.exit(1)
        EOF

        python run_migrations.py

    - name: Test deployment
      run: |
        # Get the function URL
        FUNCTION_URL=$(aws lambda get-function-url-config --function-name bella-voice-app --query 'FunctionUrl' --output text)

        echo "üß™ Testing deployment at: $FUNCTION_URL"

        # Test health endpoint
        echo "1Ô∏è‚É£ Testing health endpoint..."
        response=$(curl -s -o /dev/null -w "%{http_code}" "${FUNCTION_URL}")
        if [ "$response" = "200" ]; then
          echo "‚úÖ Health check passed"
        else
          echo "‚ö†Ô∏è Health check status: $response (may be expected for fresh deployment)"
        fi

        # Test voice webhook endpoint with advanced call flow
        echo "2Ô∏è‚É£ Testing voice webhook endpoint..."
        webhook_response=$(curl -s -o /dev/null -w "%{http_code}" \
          -X POST "${FUNCTION_URL}twilio/voice" \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "From=%2B14035551234&CallSid=test-deployment-123&AccountSid=test")

        if [ "$webhook_response" = "200" ]; then
          echo "‚úÖ Voice webhook endpoint working"
        else
          echo "‚ùå Voice webhook failed: $webhook_response"
          exit 1
        fi

        # Test advanced features by checking TwiML response
        echo "3Ô∏è‚É£ Testing conversation flow TwiML..."
        twiml_content=$(curl -s -X POST "${FUNCTION_URL}twilio/voice" \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "From=%2B14035551234&CallSid=test-conversation-456&AccountSid=test")

        if echo "$twiml_content" | grep -q "<Say"; then
          echo "‚úÖ Advanced conversation flow active - TwiML generated"
        else
          echo "‚ö†Ô∏è  Basic response detected - advanced flow may not be active"
          echo "Response: $twiml_content"
        fi

        echo "üéâ All deployment tests passed!"

    - name: Update Twilio webhook URL
      run: |
        # Get the function URL for Twilio webhook configuration
        FUNCTION_URL=$(aws lambda get-function-url-config --function-name bella-voice-app --query 'FunctionUrl' --output text)
        echo "üîó Update your Twilio webhook URL to: ${FUNCTION_URL}twilio/voice"
        echo "   Go to: https://console.twilio.com/us1/develop/phone-numbers/manage/incoming"

  deploy-ecr-ec2:
    if: github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, '[deploy-ec2]')
    needs: test
    runs-on: ubuntu-latest

    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --image-scanning-configuration scanOnPush=true

        # Build production Docker image
        docker build -f Dockerfile.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

        # Push images
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

        # Output image URI for deployment
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        IMAGE_URI: ${{ steps.build-image.outputs.image }}
      run: |
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$EC2_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts

        # Deploy to EC2
        ssh -i ~/.ssh/deploy_key $EC2_USER@$EC2_HOST << EOF
          set -e
          echo "üöÄ Starting deployment on EC2..."

          # Navigate to application directory
          cd /opt/bella-voice-app

          # Configure AWS CLI (uses IAM role attached to EC2)
          aws configure set default.region ${{ env.AWS_REGION }}

          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}

          # Update docker-compose with new image
          sed -i.bak "s|image: .*bella-voice-app.*|image: $IMAGE_URI|" docker-compose.prod.yml

          # Pull new image
          docker pull $IMAGE_URI

          # Stop and remove old containers
          docker-compose -f docker-compose.prod.yml down --remove-orphans

          # Start with new image
          docker-compose -f docker-compose.prod.yml up -d

          # Wait for services to be healthy
          echo "‚è≥ Waiting for services to be ready..."
          sleep 30

          # Check health
          docker-compose -f docker-compose.prod.yml ps

          # Test application
          if curl -f http://localhost:8000/healthz > /dev/null 2>&1; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            docker-compose -f docker-compose.prod.yml logs app
            exit 1
          fi

          echo "üéâ Deployment completed successfully!"
        EOF

    - name: Test production deployment
      env:
        PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
      run: |
        if [ -n "$PRODUCTION_URL" ]; then
          echo "üß™ Testing production deployment..."

          # Test health endpoint
          if curl -f "$PRODUCTION_URL/healthz" > /dev/null 2>&1; then
            echo "‚úÖ Production health check passed"
          else
            echo "‚ùå Production health check failed"
            exit 1
          fi

          # Test Twilio webhook
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST "$PRODUCTION_URL/twilio/voice" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "From=%2B14035551234&CallSid=test-deployment&AccountSid=test")

          if [ "$response" = "200" ]; then
            echo "‚úÖ Twilio webhook endpoint working"
          else
            echo "‚ùå Twilio webhook failed: $response"
            exit 1
          fi

          echo "üéâ All production tests passed!"
        else
          echo "‚ö†Ô∏è PRODUCTION_URL not set, skipping production tests"
        fi

  notify:
    if: always()
    needs: [test, deploy-lambda, deploy-ecr-ec2]
    runs-on: ubuntu-latest

    steps:
    - name: Notify deployment status
      run: |
        echo "üìä Deployment Summary:"
        echo "======================"

        # Lambda deployment status
        if [ "${{ needs.deploy-lambda.result }}" = "success" ]; then
          echo "‚úÖ Lambda deployment: SUCCESS"
        elif [ "${{ needs.deploy-lambda.result }}" = "skipped" ]; then
          echo "‚è≠Ô∏è Lambda deployment: SKIPPED"
        else
          echo "‚ùå Lambda deployment: FAILED"
        fi

        # EC2 deployment status
        if [ "${{ needs.deploy-ecr-ec2.result }}" = "success" ]; then
          echo "‚úÖ EC2 deployment: SUCCESS"
        elif [ "${{ needs.deploy-ecr-ec2.result }}" = "skipped" ]; then
          echo "‚è≠Ô∏è EC2 deployment: SKIPPED"
        else
          echo "‚ùå EC2 deployment: FAILED"
        fi

        echo ""
        echo "üìù Notes:"
        if [ "${{ needs.deploy-lambda.result }}" = "success" ]; then
          echo "üîó Lambda: Remember to update Twilio webhook URL in console"
        fi
        if [ "${{ needs.deploy-ecr-ec2.result }}" = "success" ]; then
          echo "üåê EC2: Application deployed via ECR"
        fi
        if [ "${{ needs.deploy-ecr-ec2.result }}" = "skipped" ]; then
          echo "üí° To deploy to EC2: Include '[deploy-ec2]' in commit message"
        fi
name: Deploy Bella V3 Cost-Optimized

on:
  push:
    branches: [ main, production ]
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]

env:
  EC2_HOST: ${{ secrets.EC2_HOST }}
  EC2_USER: ubuntu
  SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
  AWS_REGION: ca-central-1

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run security checks
      run: |
        bandit -r app/ -f json -o bandit-report.json || true
        safety check --json > safety-report.json || true

    - name: Run tests
      env:
        DATABASE_URL: "postgresql+asyncpg://bella_user:test_password@localhost:5432/bella_test_db"
        POSTGRES_PASSWORD: "test_password"
        BELLA_API_KEY: "test_key"
        OPENAI_API_KEY: "test_key"
        TWILIO_ACCOUNT_SID: "test_sid"
        TWILIO_AUTH_TOKEN: "test_token"
        TWILIO_PHONE_NUMBER: "+15551234567"
        GOOGLE_CALENDAR_ENABLED: "false"
        APP_ENV: "testing"
      run: |
        pytest tests/ -v --cov=app --cov-report=xml --cov-report=term

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          bandit-report.json
          safety-report.json
          coverage.xml

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    # Allow manual deploy bypass with [skip-tests] in commit message
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production') && (needs.test.result == 'success' || contains(github.event.head_commit.message, '[skip-tests]'))

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2

    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/bella-key.pem
        chmod 600 ~/.ssh/bella-key.pem

        # Enhanced SSH connectivity setup with comprehensive retry logic
        echo "🔧 Testing SSH connectivity to ${{ env.EC2_HOST }}..."

        # Configure SSH client options for reliability
        echo "Host ${{ env.EC2_HOST }}" >> ~/.ssh/config
        echo "    ServerAliveInterval 30" >> ~/.ssh/config
        echo "    ServerAliveCountMax 3" >> ~/.ssh/config
        echo "    ConnectTimeout 30" >> ~/.ssh/config
        echo "    ConnectionAttempts 3" >> ~/.ssh/config
        echo "    TCPKeepAlive yes" >> ~/.ssh/config
        echo "    BatchMode yes" >> ~/.ssh/config

        # Try ssh-keyscan with enhanced retry logic
        KEYSCAN_SUCCESS=false
        for i in {1..5}; do
          echo "🔑 Attempt $i/5: Running ssh-keyscan..."
          if timeout 45 ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "✅ SSH keyscan successful on attempt $i"
            KEYSCAN_SUCCESS=true
            break
          else
            echo "❌ SSH keyscan failed on attempt $i"
            if [ $i -lt 5 ]; then
              WAIT_TIME=$((i * 15))
              echo "⏳ Waiting ${WAIT_TIME} seconds before retry..."
              sleep $WAIT_TIME
            fi
          fi
        done

        # Fallback configuration if keyscan fails
        if [ "$KEYSCAN_SUCCESS" = false ]; then
          echo "🔧 Keyscan failed, using fallback SSH configuration..."
          echo "Host ${{ env.EC2_HOST }}" >> ~/.ssh/config
          echo "    StrictHostKeyChecking no" >> ~/.ssh/config
          echo "    UserKnownHostsFile /dev/null" >> ~/.ssh/config
        fi

        # Test SSH connectivity before proceeding
        echo "🧪 Testing SSH connection..."
        for i in {1..3}; do
          if ssh -i ~/.ssh/bella-key.pem -o ConnectTimeout=30 -o BatchMode=yes ${{ env.EC2_USER }}@${{ env.EC2_HOST }} "echo 'SSH connection test successful'"; then
            echo "✅ SSH connection verified on attempt $i"
            break
          else
            echo "❌ SSH connection test failed on attempt $i"
            if [ $i -eq 3 ]; then
              echo "🚨 SSH connection verification failed after 3 attempts"
              exit 1
            else
              echo "⏳ Waiting 20 seconds before retry..."
              sleep 20
            fi
          fi
        done

        # Verify SSH key format
        echo "🔍 Verifying SSH key format..."
        if ssh-keygen -l -f ~/.ssh/bella-key.pem; then
          echo "✅ SSH key format is valid"
        else
          echo "❌ SSH key format issue detected"
          exit 1
        fi

    - name: Deploy to EC2
      env:
        ECR_REGISTRY: 291878986264.dkr.ecr.ca-central-1.amazonaws.com
        ECR_REPOSITORY: bella-v3
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Smart container cleanup with state-based success detection
        echo "🛑 Checking container state and cleaning up if needed..."
        CLEANUP_SUCCESS=false

        # First, check if cleanup is even needed
        echo "🔍 Checking current container state..."
        if ssh -i ~/.ssh/bella-key.pem \
          -o StrictHostKeyChecking=no \
          -o ConnectTimeout=30 \
          -o BatchMode=yes \
          ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
          "cd ~/bella_v3 || mkdir -p ~/bella_v3 && cd ~/bella_v3 && \
           BELLA_CONTAINERS=\$(docker ps -q --filter 'name=bella') && \
           if [ -z \"\$BELLA_CONTAINERS\" ]; then \
             echo '✅ No bella containers running - system is already clean'; \
             echo '📊 Current container status:'; \
             docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'; \
             exit 0; \
           else \
             echo '🔍 Found bella containers that need cleanup:'; \
             docker ps --filter 'name=bella' --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'; \
             exit 1; \
           fi"; then
          echo "✅ System is already clean - no cleanup needed"
          CLEANUP_SUCCESS=true
        else
          echo "🧹 Cleanup required - proceeding with container removal..."

          # Perform cleanup with state-based success detection
          for i in {1..3}; do
            echo "🔄 Cleanup attempt $i/3..."

            if ssh -i ~/.ssh/bella-key.pem \
              -o StrictHostKeyChecking=no \
              -o ConnectTimeout=30 \
              -o BatchMode=yes \
              ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
              "export AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' && \
               export AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' && \
               cd ~/bella_v3 && \
               echo '🛑 Stopping bella containers...' && \
               docker ps -q --filter 'name=bella' | xargs -r docker stop --timeout=10 && \
               docker ps -aq --filter 'name=bella' | xargs -r docker rm -f && \
               echo '🔄 Docker Compose cleanup...' && \
               docker compose -f docker-compose.cost-optimized.yml down --volumes --remove-orphans --timeout 30 >/dev/null 2>&1 || true && \
               echo '🌐 Network cleanup...' && \
               docker network ls --filter 'name=bella' -q | xargs -r docker network rm >/dev/null 2>&1 || true && \
               echo '📦 Volume cleanup...' && \
               docker volume ls --filter 'name=bella' -q | xargs -r docker volume rm >/dev/null 2>&1 || true && \
               echo '🔌 Port cleanup...' && \
               sudo pkill -f 'docker-proxy.*8000' >/dev/null 2>&1 || true && \
               sudo fuser -k 8000/tcp >/dev/null 2>&1 || true && \
               sudo lsof -ti:8000 | xargs -r sudo kill -9 >/dev/null 2>&1 || true && \
               sleep 5 && \
               echo '🔍 Verifying cleanup success...' && \
               REMAINING_CONTAINERS=\$(docker ps -q --filter 'name=bella') && \
               if [ -z \"\$REMAINING_CONTAINERS\" ]; then \
                 echo '✅ Cleanup verification: No bella containers remain'; \
                 echo '📊 Final system state:'; \
                 docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'; \
                 exit 0; \
               else \
                 echo '⚠️ Cleanup verification: Some containers still running'; \
                 docker ps --filter 'name=bella' --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'; \
                 exit 1; \
               fi"; then
              echo "✅ Cleanup successful on attempt $i"
              CLEANUP_SUCCESS=true
              break
            else
              echo "❌ Cleanup attempt $i failed"
              if [ $i -lt 3 ]; then
                echo "⏳ Waiting 20 seconds before retry..."
                sleep 20
              fi
            fi
          done
        fi

        # Final status
        if [ "$CLEANUP_SUCCESS" = false ]; then
          echo "🚨 Cleanup failed after 3 attempts - performing emergency cleanup"
          ssh -i ~/.ssh/bella-key.pem ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "docker kill \$(docker ps -q) >/dev/null 2>&1 || true && \
             docker rm \$(docker ps -aq) >/dev/null 2>&1 || true && \
             echo '🚨 Emergency cleanup completed'"
        else
          echo "✅ Container cleanup completed successfully"
        fi

        # Enhanced file sync with retry logic
        echo "📁 Syncing project files to EC2..."
        SYNC_SUCCESS=false

        for i in {1..3}; do
          echo "📤 Attempt $i/3: Syncing files to EC2..."

          if rsync -avz --delete --timeout=300 \
            --exclude='.git/' \
            --exclude='node_modules/' \
            --exclude='*.log' \
            --exclude='.env*' \
            --exclude='data/' \
            --exclude='__pycache__/' \
            --exclude='*.pyc' \
            --exclude='.pytest_cache/' \
            -e "ssh -i ~/.ssh/bella-key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o BatchMode=yes" \
            ./ ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:~/bella_v3/; then
            echo "✅ File sync successful on attempt $i"
            SYNC_SUCCESS=true
            break
          else
            echo "❌ File sync failed on attempt $i"
            if [ $i -lt 3 ]; then
              echo "⏳ Waiting 15 seconds before retry..."
              sleep 15
            fi
          fi
        done

        if [ "$SYNC_SUCCESS" = false ]; then
          echo "🚨 File sync failed after 3 attempts"
          exit 1
        fi

        # Build on EC2 (native ARM64) and push to ECR
        echo "🔨 Building and pushing to ECR..."
        ssh -i ~/.ssh/bella-key.pem \
          -o StrictHostKeyChecking=no \
          -o ConnectTimeout=30 \
          -o ServerAliveInterval=60 \
          -o ServerAliveCountMax=10 \
          ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << EOF
          cd ~/bella_v3

          # Configure AWS CLI for ECR access
          export AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}'
          export AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}'
          export AWS_DEFAULT_REGION='${{ env.AWS_REGION }}'

          # Login to ECR
          echo "🔐 Logging into ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin $ECR_REGISTRY

          # Clean up old images to save space
          echo "🧹 Cleaning up old images..."
          docker system prune -f || true

          # Build image natively on ARM64 EC2
          echo "🔨 Building Docker image natively on ARM64..."
          docker build -f Dockerfile.cost-optimized \
            -t bella-v3:latest \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .

          # Push to ECR for future deployments
          echo "📤 Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "✅ Build and push completed successfully"
        EOF

        # Enhanced container startup with pre-startup cleanup
        echo "🚀 Starting application containers with pre-startup verification..."

        for startup_attempt in {1..3}; do
          echo "🔄 Startup attempt $startup_attempt/3..."

          if ssh -i ~/.ssh/bella-key.pem \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=5 \
            -o BatchMode=yes \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "cd ~/bella_v3 && \
             export AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' && \
             export AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' && \
             echo '🔍 Pre-startup verification...' && \
             if netstat -tlnp | grep :8000; then \
               echo '⚠️ Port 8000 still in use, performing emergency cleanup...' && \
               sudo lsof -ti:8000 | xargs -r sudo kill -9 && \
               sleep 5; \
             fi && \
             echo '🚀 Starting containers with force recreate...' && \
             docker compose -f docker-compose.cost-optimized.yml up -d --force-recreate --remove-orphans && \
             echo '⏳ Waiting for services to start (30s)...' && \
             sleep 30 && \
             echo '🔍 Verifying container health...' && \
             docker compose -f docker-compose.cost-optimized.yml ps && \
             echo '🗄️ Running database migrations...' && \
             docker compose -f docker-compose.cost-optimized.yml exec -T app alembic upgrade head && \
             echo '✅ Container startup completed successfully'"; then
            echo "✅ Container startup successful on attempt $startup_attempt"
            break
          else
            echo "❌ Container startup failed on attempt $startup_attempt"
            if [ $startup_attempt -lt 3 ]; then
              echo "⏳ Waiting 30 seconds before retry..."
              sleep 30
              # Emergency port cleanup between attempts
              ssh -i ~/.ssh/bella-key.pem ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
                "sudo lsof -ti:8000 | xargs -r sudo kill -9 || true && sleep 5"
            else
              echo "🚨 All startup attempts failed!"
              exit 1
            fi
          fi
        done

        # Enhanced health check with comprehensive validation and diagnostics
        echo "🩺 Running comprehensive health checks with enhanced diagnostics..."
        HEALTH_SUCCESS=false

        # Allow extra time for containers to fully start
        echo "⏳ Waiting 60 seconds for services to fully initialize..."
        sleep 60

        for attempt in {1..3}; do
          echo "🔍 Health check attempt $attempt/3..."

          if ssh -i ~/.ssh/bella-key.pem \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=5 \
            -o BatchMode=yes \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "cd ~/bella_v3 && \
             echo '🏥 Detailed container status check...' && \
             docker compose -f docker-compose.cost-optimized.yml ps -a && \
             echo '🔍 Container health details...' && \
             docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' && \
             echo '🌐 Network connectivity check...' && \
             netstat -tlnp | grep :8000 && \
             echo '📡 Testing application endpoints...' && \
             for i in {1..20}; do \
               echo \"Health check iteration $i/20 ($(date))\"; \
               if curl -f -s --connect-timeout 15 --max-time 45 http://localhost:8000/healthz; then \
                 echo '✅ Health endpoint responded successfully'; \
                 echo '🔍 Testing readiness endpoint...'; \
                 if curl -f -s --connect-timeout 15 --max-time 45 http://localhost:8000/readyz; then \
                   echo '✅ Ready endpoint confirmed - Application is fully operational'; \
                   echo '📊 Final deployment verification:'; \
                   curl -s http://localhost:8000/healthz | head -5; \
                   exit 0; \
                 else \
                   echo '⚠️ Ready endpoint not responding, but health is OK'; \
                   echo '📊 Health endpoint response:'; \
                   curl -s http://localhost:8000/healthz | head -5; \
                 fi; \
                 echo '✅ Basic health check passed - Application is operational'; \
                 exit 0; \
               else \
                 echo \"❌ Attempt $i/20 failed, waiting 20s...\"; \
                 if [ $i -eq 10 ]; then \
                   echo '🔍 Mid-check diagnostics:'; \
                   docker compose -f docker-compose.cost-optimized.yml logs app --tail=10; \
                   netstat -tlnp | grep :8000 || echo 'Port 8000 not bound'; \
                 fi; \
               fi; \
               sleep 20; \
             done; \
             echo '❌ Health check failed after 20 attempts (6.7 minutes)'; \
             echo '📋 Complete container logs for debugging:'; \
             docker compose -f docker-compose.cost-optimized.yml logs app --tail=50; \
             echo '🔍 Network and port diagnostic:'; \
             netstat -tlnp | grep :8000 || echo 'Port 8000 not bound'; \
             ss -tulpn | grep :8000 || echo 'Port 8000 not found in ss'; \
             echo '🐳 Docker system status:'; \
             docker system df; \
             exit 1"; then
            echo "✅ Health check passed on attempt $attempt"
            HEALTH_SUCCESS=true
            break
          else
            echo "❌ Health check failed on attempt $attempt"
            if [ $attempt -lt 3 ]; then
              echo "⏳ Waiting 45 seconds before retry..."
              sleep 45
              # Additional diagnostic logging between attempts
              ssh -i ~/.ssh/bella-key.pem ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
                "echo '🔍 Inter-attempt diagnostics:' && \
                 docker ps && \
                 docker compose -f ~/bella_v3/docker-compose.cost-optimized.yml logs app --tail=5"
            fi
          fi
        done

        if [ "$HEALTH_SUCCESS" = false ]; then
          echo "🚨 All health check attempts failed after comprehensive testing"
          echo "🔍 Gathering final diagnostic information..."
          ssh -i ~/.ssh/bella-key.pem ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "cd ~/bella_v3 && \
             echo '📊 Final system state:' && \
             docker ps -a && \
             docker compose -f docker-compose.cost-optimized.yml logs --tail=100" || true
          exit 1
        fi

        echo "✅ Deployment completed successfully!"

    - name: Verify deployment
      run: |
        echo "🔍 Verifying deployment status..."
        ssh -i ~/.ssh/bella-key.pem \
          -o StrictHostKeyChecking=no \
          -o ConnectTimeout=30 \
          ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << 'EOF'
          cd ~/bella_v3

          echo "🔍 Container Status:"
          docker compose -f docker-compose.cost-optimized.yml ps

          echo "🩺 Health Checks:"
          curl -s http://localhost:8000/healthz | jq '.'
          curl -s http://localhost:8000/readyz | jq '.'

          echo "📊 Resource Usage:"
          docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
        EOF

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "✅ Deployment to production successful!"
          echo "🌐 Application URL: http://${{ env.EC2_HOST }}:8000"
          echo "🩺 Health Check: http://${{ env.EC2_HOST }}:8000/healthz"
        else
          echo "❌ Deployment failed!"
          exit 1
        fi

  cleanup:
    needs: [test, build-and-deploy]
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Setup SSH key for cleanup
      if: needs.build-and-deploy.result == 'success'
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/bella-key.pem
        chmod 600 ~/.ssh/bella-key.pem

        # Robust SSH setup for cleanup
        echo "Setting up SSH for cleanup..."
        if ! timeout 30 ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
          echo "⚠️ SSH keyscan failed, using fallback config"
          echo "Host ${{ secrets.EC2_HOST }}" >> ~/.ssh/config
          echo "    StrictHostKeyChecking no" >> ~/.ssh/config
        fi

    - name: Cleanup old Docker images
      if: needs.build-and-deploy.result == 'success'
      run: |
        echo "🧹 Cleaning up old Docker images..."
        ssh -i ~/.ssh/bella-key.pem \
          -o StrictHostKeyChecking=no \
          -o ConnectTimeout=30 \
          ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
          # Remove old Docker images to save space
          docker image prune -f
          docker volume prune -f

          echo "🧹 Cleanup completed"
        EOF